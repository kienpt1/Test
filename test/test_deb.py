import os
import gc
import re
import json
import time
import pymysql
import pandas as pd
import requests as rqs
import streamlit as st
from datetime import datetime
from streamlit_autorefresh import st_autorefresh

# Webhook URL
url = "http://localhost:4587/prtg-webhook-electric-me"

# Database connection config
db_config = {
    "host": "101.99.5.34",
    "port": 3308,
    "user": "root",
    "password": "qYBwu]cSZ[*NmS.0",
    "database": "bts"
}

# Alarm mapping
ALARM_LABELS = {
    "AMABD1": "C·∫£nh b√°o ƒë·ªôt nh·∫≠p",
    "AMADR1": "C·∫£nh b√°o m·ªü c·ª≠a",
    "AMAFL1": "C·∫£nh b√°o: ng·∫≠p n∆∞·ªõc trong tr·∫°m",
    "AMAFR1": "C·∫£nh b√°o c√≥ ch√°y kh√≥i trong tr·∫°m",
    "AMATI1": "C·∫£nh b√°o nhi·ªát ƒë·ªô cao",
    "AMIAR1": "C·∫£nh b√°o: c√≥ s·ª± c·ªë ƒëi·ªÅu h√≤a",
    "AMIHU1": "C·∫£nh b√°o ƒë·ªô ·∫©m tr·∫°m cao",
    "AMIPS1": "C·∫£nh b√°o ch·∫≠p ngu·ªìn sensor"
}

@st.cache_data
def load_json(path):
    with open(path, 'r', encoding='utf-8') as file:
        return json.load(file)

def read_json(data, compare):
    return data.get(str(compare), None)

def fetch_new_messages(cursor):
    cursor.execute("SELECT * FROM messages ORDER BY id DESC LIMIT 100;")
    return cursor.fetchall()

def extract_msg_time(details):
    match = re.search(r";(\d{2}:\d{2}:\d{2}-\d{2}/\d{2}/\d{2});", details)
    if match:
        try:
            return datetime.strptime(match.group(1), "%H:%M:%S-%d/%m/%y")
        except:
            return None
    return None

def process_data(raw_data, json_data):
    structured_data = []

    alm_keys = [
        "AMATI", "AMADR", "AMAFL", "AMAFR", "AMIPS", "AMIHU",
        "AMIAC", "AMIGN", "AMIAR", "AMIAL", "AMIAP",
        "AMIDC", "AMIDE", "AMIX1", "AMIX2", "AMIX3",
        "BTI0", "BHU", "BAV", "BAP", "BDV", "BDE"
    ]
    seq_keys = [
        "BTI0", "BTO0", "BHU0", "BAV", "BAP", "BAC0", "BAF", "BSE0",
        "BFA", "BFD", "BPW", "BDV", "BDC", "BDE", "BDR", "BFR",
        "BFL", "BPS", "BX1", "BX2", "BX3"
    ]

    for data in raw_data:
        id_value, status, _, value, start_time, _, end_time, details = data

        extracted_data = {
            "Start_Time": start_time,
            "End_Time": end_time,
        }

        eqid_match = re.search(r"EQID=(\d+)", details)
        msg_type_match = re.search(r"EQID=\d+;(ALM|SEQ);", details)

        extracted_data["EQID"] = eqid_match.group(1) if eqid_match else None
        extracted_data["Type"] = msg_type_match.group(1) if msg_type_match else "UNKNOWN"
        extracted_data["Location"] = read_json(json_data, extracted_data["EQID"])
        
        keys = alm_keys if extracted_data["Type"] == "ALM" else seq_keys
        
        for key in keys:
            match = re.search(rf"{key}[-:]?([0-9\.]+)", details)
            extracted_data[key] = match.group(1) if match else None

        alert_descriptions = []
        if extracted_data["Type"] == "ALM":
            # for key, desc in ALARM_LABELS.items():
            #     if extracted_data.get(key[:-1]) == key[-1]:
            #         alert_descriptions.append(desc)
            ac_status = extracted_data.get("AMIAC")
            gen_status = extracted_data.get("AMIGN")

            # if ac_status == "1":
            #     if gen_status == "1":
            #         alert_descriptions.append("M·∫•t ƒëi·ªán AC - M√°y ph√°t ƒëang ch·∫°y")
            #     elif gen_status == "0":
            #         alert_descriptions.append("‚ö†Ô∏è M·∫•t ƒëi·ªán AC - M√°y ph√°t KH√îNG ch·∫°y!")
            #     else:
            #         alert_descriptions.append("M·∫•t ƒëi·ªán AC")
            # elif ac_status == "0":
            #     alert_descriptions.append("C√≥ ƒëi·ªán AC")
            if ac_status == "1":
                if gen_status == "1":
                    alert_descriptions.append("M·∫•t ƒëi·ªán AC - M√°y ph√°t ƒëang ch·∫°y")
                elif gen_status == "0":
                    alert_descriptions.append("‚ö†Ô∏è M·∫•t ƒëi·ªán AC - M√°y ph√°t KH√îNG ch·∫°y!")
                else:
                    alert_descriptions.append("M·∫•t ƒëi·ªán AC")
            elif ac_status == "0":
                if gen_status == "1":
                    alert_descriptions.append("C√≥ ƒëi·ªán AC ƒëang s·ª≠ d·ª•ng ƒëi·ªán¬†c·ªßa¬†m√°y¬†ph√°t")
                elif gen_status == "0":
                    alert_descriptions.append("C√≥ ƒëi·ªán AC, kh√¥ng ch·∫°y¬†m√°y¬†ph√°t")
                else:
                    alert_descriptions.append("C√≥ ƒëi·ªán AC")


            # C√°c c·∫£nh b√°o c√≤n l·∫°i
            for key, desc in ALARM_LABELS.items():
                if key.startswith("AMIAC") or key.startswith("AMIGN"):
                    continue  # ƒë√£ x·ª≠ l√Ω ri√™ng b√™n tr√™n
                if extracted_data.get(key[:-1]) == key[-1]:
                    alert_descriptions.append(desc)

        extracted_data["Alert_Description"] = ", ".join(alert_descriptions) if alert_descriptions else None
        extracted_data["Message_Time"] = extract_msg_time(details)
        structured_data.append(extracted_data)

    df = pd.DataFrame(structured_data)
    df = df.dropna(subset=["EQID", "Message_Time"])
    df = df.sort_values("Message_Time").groupby("EQID", as_index=False).tail(1)

    print(f"GC Collected: {gc.collect()}")
    return alert_descriptions,df

def load_json_data():
    json_path = "locations.json"
    json_data_cp = load_json(json_path)
    return {eqid: info["location_name"] for eqid, info in json_data_cp.items()}


def handle_exclude_eqids():
    st.subheader("‚ùå Lo·∫°i b·ªè to√†n b·ªô c·∫£nh b√°o c·ªßa tr·∫°m")
    EXCLUDE_FILE = "excluded_eqids.json"

    if "excluded_eqids" not in st.session_state:
        if os.path.exists(EXCLUDE_FILE):
            try:
                with open(EXCLUDE_FILE, "r", encoding="utf-8") as f:
                    st.session_state.excluded_eqids = set(json.load(f))
            except json.JSONDecodeError:
                st.warning("‚ö†Ô∏è L·ªói ƒë·ªãnh d·∫°ng trong excluded_eqids.json. Kh·ªüi t·∫°o l·∫°i.")
                st.session_state.excluded_eqids = set()
        else:
            st.session_state.excluded_eqids = set()

    with st.form("exclude_station_form"):
        exclude_eqid_input = st.text_input("Nh·∫≠p EQID tr·∫°m c·∫ßn lo·∫°i", "")
        submitted = st.form_submit_button("Add")
        returned = st.form_submit_button("Delete")

        if submitted and exclude_eqid_input.strip():
            st.session_state.excluded_eqids.add(exclude_eqid_input.strip())
            with open(EXCLUDE_FILE, "w", encoding="utf-8") as f:
                json.dump(list(st.session_state.excluded_eqids), f, indent=2)
            st.success(f"‚úÖ ƒê√£ lo·∫°i tr·∫°m c√≥ EQID = {exclude_eqid_input.strip()}")

        if returned:
            st.session_state.excluded_eqids = set()
            with open(EXCLUDE_FILE, "w", encoding="utf-8") as f:
                json.dump([], f, indent=2)
            st.success("‚úÖ ƒê√£ x√≥a danh s√°ch tr·∫°m kh√¥ng b·∫Øn c·∫£nh b√°o.")


def handle_exclude_alerts():
    st.subheader("üö´ Lo·∫°i b·ªè m·ªôt s·ªë c·∫£nh b√°o c·ª• th·ªÉ theo tr·∫°m")
    EXCLUDED_ALERTS_FILE = "excluded_alerts_by_eqid.json"

    if "excluded_alerts_by_eqid" not in st.session_state:
        if os.path.exists(EXCLUDED_ALERTS_FILE):
            try:
                with open(EXCLUDED_ALERTS_FILE, "r", encoding="utf-8") as f:
                    content = f.read().strip()
                    st.session_state.excluded_alerts_by_eqid = json.loads(content) if content else {}
            except json.JSONDecodeError:
                st.warning("‚ö†Ô∏è L·ªói ƒë·ªãnh d·∫°ng trong excluded_alerts_by_eqid.json. Kh·ªüi t·∫°o l·∫°i.")
                st.session_state.excluded_alerts_by_eqid = {}
        else:
            st.session_state.excluded_alerts_by_eqid = {}

    if not isinstance(st.session_state.excluded_alerts_by_eqid, dict):
        st.session_state.excluded_alerts_by_eqid = {}

    with st.form("exclude_specific_alerts_form"):
        eqid_input = st.text_input("EQID c·ªßa tr·∫°m", "")
        alarm_options = list(ALARM_LABELS.values())
        selected_alarms = st.multiselect("Ch·ªçn lo·∫°i c·∫£nh b√°o c·∫ßn lo·∫°i", options=alarm_options)
        submitted_alarms = st.form_submit_button("Add")
        return_alarms = st.form_submit_button("Delete")

        if submitted_alarms and eqid_input.strip() and selected_alarms:
            eqid = eqid_input.strip()
            excluded = st.session_state.excluded_alerts_by_eqid.get(eqid, [])
            for alarm in selected_alarms:
                if alarm not in excluded:
                    excluded.append(alarm)
            st.session_state.excluded_alerts_by_eqid[eqid] = excluded
            with open(EXCLUDED_ALERTS_FILE, "w", encoding="utf-8") as f:
                json.dump(st.session_state.excluded_alerts_by_eqid, f, indent=2, ensure_ascii=False)
            st.success(f"‚úÖ ƒê√£ lo·∫°i {len(selected_alarms)} c·∫£nh b√°o cho tr·∫°m EQID = {eqid}")

        if return_alarms:
            st.session_state.excluded_alerts_by_eqid = {}
            with open(EXCLUDED_ALERTS_FILE, "w", encoding="utf-8") as f:
                json.dump({}, f, indent=2, ensure_ascii=False)
            st.success("‚úÖ ƒê√£ x√≥a to√†n b·ªô c·∫£nh b√°o b·ªã lo·∫°i theo tr·∫°m.")


def display_excluded_info():
    if st.session_state.get("excluded_eqids"):
        st.info("üö´ C√°c tr·∫°m ƒë√£ b·ªã lo·∫°i: " + ", ".join(st.session_state.excluded_eqids))
    if st.session_state.get("excluded_alerts_by_eqid"):
        st.info("üìå C·∫£nh b√°o b·ªã lo·∫°i theo tr·∫°m:")
        for eqid, alerts in st.session_state.excluded_alerts_by_eqid.items():
            st.write(f"‚Ä¢ **{eqid}**: {', '.join(alerts)}")


def process_and_send_alerts(json_data):
    try:
        connection = pymysql.connect(**db_config)
        cursor = connection.cursor()

        st.write("Fetching new messages...")
        raw_messages = fetch_new_messages(cursor)
        alert_descriptions, df = process_data(raw_messages, json_data)

        st.session_state.setdefault("sent_alerts", {})
        st.session_state.setdefault("active_alerts", {})

        now = datetime.now()
        current_keys = set(f"{row['EQID']}_{row['Alert_Description']}" for _, row in df.iterrows())

        to_remove = [key for key in st.session_state.active_alerts if key not in current_keys]
        for key in to_remove:
            del st.session_state.active_alerts[key]
            print(f"üßπ ƒê√£ x√≥a kh·ªèi b·ªô nh·ªõ c·∫£nh b√°o kh√¥ng c√≤n t·ªìn t·∫°i: {key}")

        for _, row in df.iterrows():
            eqid = row["EQID"]
            if eqid in st.session_state.excluded_eqids:
                continue
            if row["Type"] != "ALM":
                continue

            desc = row["Alert_Description"]
            loc = row["Location"]
            msg_time = row["Message_Time"].replace(microsecond=0)
            time_key = f"{eqid}_{desc}_{msg_time.strftime('%Y-%m-%d %H:%M:%S')}"

            if desc in st.session_state.excluded_alerts_by_eqid.get(eqid, []):
                print(f"‚èπÔ∏è B·ªè qua c·∫£nh b√°o '{desc}' t·∫°i EQID {eqid}")
                continue

            last_sent = st.session_state.sent_alerts.get(time_key)
            wait_seconds = 600 if "ƒëi·ªán AC" in (desc or "").lower() else 120

            if last_sent is None or (now - last_sent).total_seconds() > wait_seconds:
                json_payload = {
                    "status": "ok",
                    "Location": loc or "",
                    "EQID": eqid,
                    "Alert_Description": desc or "",
                    "datetime": msg_time.strftime("%Y-%m-%d %H:%M:%S")
                }
                print(json_payload)
                try:
                    response = rqs.post(url, json=json_payload, timeout=5)
                    if response.status_code == 200:
                        st.session_state.sent_alerts[time_key] = now
                        st.session_state.active_alerts[time_key] = True
                        print(f"‚úÖ G·ª≠i c·∫£nh b√°o: {json_payload}")
                    else:
                        print(f"‚ùå L·ªói g·ª≠i c·∫£nh b√°o: {response.status_code}")
                except Exception as e:
                    print(f"‚ùå L·ªói k·∫øt n·ªëi webhook: {e}")
            else:
                print(f"‚è≥ ƒê√£ g·ª≠i c·∫£nh b√°o g·∫ßn ƒë√¢y: {time_key}")
                st.session_state.active_alerts[time_key] = True

            time.sleep(1)

        st.dataframe(df, use_container_width=True)

    except Exception as e:
        st.error(f"‚ùå L·ªói: {e}")
    finally:
        try:
            cursor.close()
            connection.close()
        except:
            pass

def main():
    st.title("üì° CVCS-TEC Message Monitor Version 0.1 Low Tech")
    st.caption("Live feed of messages from MySQL and EQID mapped locations.")

    json_data = load_json_data()

    refresh_interval = st.slider("Refresh Interval (seconds)", 1, 10, 3)
    st_autorefresh(interval=refresh_interval * 1000, key="data_refresh")

    handle_exclude_eqids()
    handle_exclude_alerts()
    display_excluded_info()
    process_and_send_alerts(json_data)


if __name__ == "__main__":
    main()


